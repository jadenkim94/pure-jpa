# JPA
자바 ORM 표준 JPA 프로그래밍 학습


## 앤티티 매니저 팩토리와 앤티티
- 엔터티(Entity)는 '실제', '독립체'라는 뜻으로 데이터 모델링에서 사용되는 객체를 의미한다.

- 앤티티 매니저 팩토리는 앤티티 매니저를 만드는 객체로, 생성 비용이 크다.
한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계되어 있다. 

- 앤티티 매니저는 앤티티를 저장하는 가상의 데이터베이스로 생각하면 된다.
동시성 문제가 발생할 수 있음으로 스레드 간 공유하면 안된다.

## 영속성 컨텍스트(Persistence Context)
'엔티티를 영구 저장하는 환경' 이라는 뜻으로 엔티티 매니저로 엔티티를 저장하거나 조회하면
엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다. 

### 영속성 컨텍스트와 DB 동기화
- 트랜잭션을 commit 하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영하는데 이것을 flush 라고 한다. 

### 영속성 컨텍스트 사용의 장점
1. 1차 캐시
2. 동일성 보장
3. 트랜잭션을 지원하는 쓰기지원
4. 변경 감지
5. 지연로딩

#### 1차캐시 
영속성 컨텍스트 내부에 가지고 있는 캐시 일종의 Map 으로 키는 @Id 값은 엔티티 인스턴스  
em.find() 를 호출하면 1차 캐시에서 엔티티를 조회하고 없는 경우에만 데이터베이스에서 조회
#### 동일성 보장 
em.find() 를 통해 반복조회하는 경우 1차캐시에서 같은 인스턴스를 반환함으로 동일성을 보장한다.
#### 쓰기 지연
앤티티 매니저는 트랜잭션 커밋을 하기 전까지 내부 쿼리 저장소에 쿼리들을 모아두고, 트랜잭션을 커밋 할 때 모아둔 쿼리를
데이터베이스에 보낸다. 이것을 트랜잭션을 지원하는 쓰기 지연이라 한다.  
쿼리를 한번에 모아서 DB 로 보낼 수 있음으로 하나씩 쿼리를 보내는 것 보다 성능적으로 이점이 있다.
#### 변경감지
1. A 엔티티의 b 속성 수정
2. A 엔티티의 b, c 속성 수정  

위와 같은 수정이 필요한 경우, JPA 를 사용하지 않는다면 수정쿼리가 2개 필요하게 된다. 
만약 요구사항이 늘어나 다양한 수정이 필요하면 그만큼의 수정 쿼리가 필요하게 되어 관리가 쉽지 않다.
하지만 JPA 를 사용하면 변경감지를 통해 이런 부분을 해결한다.  
변경감지는 엔티티를 최초 보관할 때 해당 엔티티의 상태를 스냅샷을 찍어두고 플러시가 일어나는 시점에 스냅샷과 엔티티르 비교해 
변경된 엔티티를 찾아 쓰기 지연 SQL 저장소에 수정 쿼리를 보낸다.  
추가적으로 JPA의 기본적랸은 엔티티의 모든 필드를 업데이트 하는데, 데이터베이스에 보내는 데이터 전송량이 증가한다는 단점이 있지만
수정 쿼리가 항상 동일해 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성하고 재사용할 수 있다는 장점과 
데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용 할 수 있다는 장점이 있다.  
만약 컬럼이 30개 이상되면 변화되는 필드만 수정할 수 있는 @DynamicUpdate 를 통해 동적수정쿼리를 사용하는게 성능상 이점이 있을 수 있다. 

## 엔티티 생명주기 
1. 비영속 : 영속성 컨텍스트와 관계가 없는 상태 
2. 영속 : 영속성 컨텍스트에 저장된 상태 
3. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제 : 삭제된 상태
  
em = entityManager  
A 객체를 새로 생성하면 준영속 상태이다.  
em.persist(A) 나 em.find(A), JPQL 을 통해 A 를 조회하면
A 는 영속상태이다.  
em.detach(A), em.close(), em.clear() 를 하는 경우 A는 준영속 상태이다.
em.remove(A) 를 하면 영속성컨텍스트에서 삭제하고, 커밋 시점에 DB에서도 삭제된다.

## 플러시(flush)
플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 
em.flush() 를 호출, 트랜잭션 커밋, JPQL 쿼리 실행시 플러시가 호출된다.  
JPQL 호출 시 플러시가 호출되는 이유는 JPQL은 SQL로 변형되어 데이터베이스에서 엔티티를 조회하게 되는데
영속석 컨텍스트의 내용들이 반영되어 있지 않은 경우 문제가 발생할 수 때문이다.  
  
em.persist(memberA);  
em.persist(memberB);  
query = em.createQuery("select m from Member m", Member.class);  
List<Member> members = query.getResultList();  

위와 같은 경우 플러시가 일어나지 않았다면 members 에는 memberA, memberB 가 없다는 문제가 발생